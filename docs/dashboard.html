<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>CoMMpass Analysis Dashboard - Interactive</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="dashboard_shinylive_files/libs/clipboard/clipboard.min.js"></script>
<script src="dashboard_shinylive_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="dashboard_shinylive_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="dashboard_shinylive_files/libs/quarto-html/popper.min.js"></script>
<script src="dashboard_shinylive_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="dashboard_shinylive_files/libs/quarto-html/anchor.min.js"></script>
<link href="dashboard_shinylive_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="dashboard_shinylive_files/libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="dashboard_shinylive_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="dashboard_shinylive_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="dashboard_shinylive_files/libs/bootstrap/bootstrap-ed013ce07696383e9b85cfdb5ae143ca.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<meta name="shinylive:serviceworker_dir" content=".">
<script src="dashboard_shinylive_files/libs/quarto-contrib/shinylive-0.9.1/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="dashboard_shinylive_files/libs/quarto-contrib/shinylive-0.9.1/shinylive/run-python-blocks.js" type="module"></script>
<link href="dashboard_shinylive_files/libs/quarto-contrib/shinylive-0.9.1/shinylive/shinylive.css" rel="stylesheet">
<link href="dashboard_shinylive_files/libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul class="collapse">
  <li><a href="#about-this-dashboard" id="toc-about-this-dashboard" class="nav-link active" data-scroll-target="#about-this-dashboard">About This Dashboard</a></li>
  <li><a href="#interactive-dashboard" id="toc-interactive-dashboard" class="nav-link" data-scroll-target="#interactive-dashboard">Interactive Dashboard</a></li>
  <li><a href="#usage-instructions" id="toc-usage-instructions" class="nav-link" data-scroll-target="#usage-instructions">Usage Instructions</a></li>
  <li><a href="#technical-notes" id="toc-technical-notes" class="nav-link" data-scroll-target="#technical-notes">Technical Notes</a></li>
  <li><a href="#building-this-vignette" id="toc-building-this-vignette" class="nav-link" data-scroll-target="#building-this-vignette">Building This Vignette</a></li>
  </ul>
</nav>
</div>
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">CoMMpass Analysis Dashboard - Interactive</h1>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<section id="about-this-dashboard" class="level2">
<h2 class="anchored" data-anchor-id="about-this-dashboard">About This Dashboard</h2>
<p>This is an interactive dashboard for exploring CoMMpass multiple myeloma analysis results, running entirely in your web browser using Shinylive (WebAssembly). No R server required!</p>
<p><strong>Features:</strong> - Quality Control visualization - Differential Expression analysis - Survival Analysis with Kaplan-Meier curves - Pathway Enrichment results - All analysis runs in your browser</p>
<p><strong>Note:</strong> First load may take 30-60 seconds while packages download. Subsequent visits will be faster due to caching.</p>
</section>
<section id="interactive-dashboard" class="level2">
<h2 class="anchored" data-anchor-id="interactive-dashboard">Interactive Dashboard</h2>
<pre class="shinylive-r" data-engine="r"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 800

# Load required packages
# Using modern Shinylive pattern - packages auto-bundle with dependencies
library(shiny)
library(bslib)
library(plotly)
library(DT)
library(dplyr)
library(tidyr)
library(ggplot2)  # Now includes munsell automatically via Shinylive 0.8.0+
library(survival)

# ============================================================================
# Data Generation Functions
# ============================================================================

generate_example_counts &lt;- function(n_genes = 500, n_samples = 40) {
  # Generate realistic RNA-seq counts
  set.seed(123)
  
  gene_names &lt;- paste0("GENE", seq_len(n_genes))
  sample_names &lt;- paste0("SAMPLE", seq_len(n_samples))
  
  # Simulate counts with overdispersion
  counts &lt;- matrix(
    rnbinom(n_genes * n_samples, mu = 500, size = 2),
    nrow = n_genes,
    dimnames = list(gene_names, sample_names)
  )
  
  # Add some differential expression for first 50 genes
  group1_samples &lt;- seq_len(n_samples / 2)
  counts[1:50, group1_samples] &lt;- counts[1:50, group1_samples] * 2
  
  return(counts)
}

generate_example_clinical &lt;- function(n_samples = 40) {
  set.seed(123)
  
  sample_names &lt;- paste0("SAMPLE", seq_len(n_samples))
  
  clinical &lt;- data.frame(
    sample = sample_names,
    age = round(rnorm(n_samples, mean = 65, sd = 10)),
    stage = sample(c("I", "II", "III"), n_samples, replace = TRUE),
    risk_group = sample(c("Standard", "High"), n_samples, replace = TRUE),
    response = sample(c("CR", "PR", "SD", "PD"), n_samples, replace = TRUE),
    os_time = round(rexp(n_samples, rate = 1/365) * 365),
    os_status = rbinom(n_samples, 1, 0.4),
    pfs_time = round(rexp(n_samples, rate = 1/250) * 250),
    pfs_status = rbinom(n_samples, 1, 0.5),
    stringsAsFactors = FALSE
  )
  
  return(clinical)
}

generate_example_qc &lt;- function(counts) {
  data.frame(
    sample = colnames(counts),
    total_counts = colSums(counts),
    detected_genes = colSums(counts &gt; 0),
    is_outlier = FALSE,
    stringsAsFactors = FALSE
  )
}

generate_example_de &lt;- function(counts) {
  n_genes &lt;- nrow(counts)
  gene_names &lt;- rownames(counts)
  
  # Simulate DE results
  list(
    DESeq2 = data.frame(
      gene = gene_names,
      baseMean = rowMeans(counts),
      log2FoldChange = c(rnorm(50, mean = 2, sd = 0.5), rnorm(n_genes - 50, mean = 0, sd = 0.3)),
      lfcSE = runif(n_genes, 0.1, 0.3),
      stat = rnorm(n_genes, 0, 2),
      pvalue = c(runif(50, 0, 0.01), runif(n_genes - 50, 0, 1)),
      padj = c(runif(50, 0, 0.05), runif(n_genes - 50, 0.05, 1)),
      stringsAsFactors = FALSE
    ),
    edgeR = data.frame(
      gene = gene_names,
      logFC = c(rnorm(50, mean = 2, sd = 0.5), rnorm(n_genes - 50, mean = 0, sd = 0.3)),
      logCPM = log2(rowMeans(counts) + 1),
      PValue = c(runif(50, 0, 0.01), runif(n_genes - 50, 0, 1)),
      FDR = c(runif(50, 0, 0.05), runif(n_genes - 50, 0.05, 1)),
      stringsAsFactors = FALSE
    ),
    limma = data.frame(
      gene = gene_names,
      logFC = c(rnorm(50, mean = 2, sd = 0.5), rnorm(n_genes - 50, mean = 0, sd = 0.3)),
      AveExpr = rowMeans(log2(counts + 1)),
      t = rnorm(n_genes, 0, 2),
      P.Value = c(runif(50, 0, 0.01), runif(n_genes - 50, 0, 1)),
      adj.P.Val = c(runif(50, 0, 0.05), runif(n_genes - 50, 0.05, 1)),
      B = rnorm(n_genes, 0, 2),
      stringsAsFactors = FALSE
    )
  )
}

generate_example_pathways &lt;- function() {
  data.frame(
    pathway = c(
      "HALLMARK_MYC_TARGETS_V1", "HALLMARK_E2F_TARGETS",
      "HALLMARK_G2M_CHECKPOINT", "HALLMARK_APOPTOSIS",
      "HALLMARK_UNFOLDED_PROTEIN_RESPONSE", "HALLMARK_INFLAMMATORY_RESPONSE",
      "KEGG_PROTEASOME", "KEGG_CELL_CYCLE",
      "REACTOME_IMMUNE_SYSTEM", "GO_DNA_REPAIR",
      "HALLMARK_P53_PATHWAY", "KEGG_OXIDATIVE_PHOSPHORYLATION",
      "REACTOME_CELL_CYCLE", "GO_MITOCHONDRION",
      "HALLMARK_TNFA_SIGNALING_VIA_NFKB"
    ),
    p_value = c(0.001, 0.002, 0.003, 0.004, 0.005, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1),
    gene_count = c(25, 22, 20, 18, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6),
    pathway_size = 200,
    NES = c(2.3, 2.1, 1.9, -1.8, 1.7, -1.6, 1.5, 1.4, -1.3, 1.2, 1.1, -1.0, 0.9, 0.8, -0.7),
    q_value = c(0.01, 0.01, 0.02, 0.02, 0.03, 0.05, 0.08, 0.1, 0.12, 0.15, 0.18, 0.2, 0.22, 0.24, 0.26),
    stringsAsFactors = FALSE
  )
}

# ============================================================================
# Module: Data Loader
# ============================================================================

mod_data_loader_ui &lt;- function(id) {
  ns &lt;- NS(id)
  
  tagList(
    layout_columns(
      col_widths = c(4, 8),
      
      card(
        card_header("Data Source"),
        card_body(
          radioButtons(
            ns("data_source"),
            "Select Data Source:",
            choices = list("Example Data (Simulated)" = "example"),
            selected = "example"
          ),
          
          p(class = "text-muted",
            "This demo uses simulated CoMMpass-like data with:",
            tags$ul(
              tags$li("500 genes, 40 samples"),
              tags$li("50 differentially expressed genes"),
              tags$li("Simulated survival outcomes")
            )
          ),
          
          hr(),
          
          actionButton(
            ns("load_data"),
            "Load Example Data",
            class = "btn-primary btn-lg",
            icon = icon("play")
          ),
          
          br(), br(),
          
          verbatimTextOutput(ns("load_status"))
        )
      ),
      
      card(
        card_header("Data Summary"),
        card_body(
          h5("Loaded Datasets"),
          tableOutput(ns("data_summary")),
          
          hr(),
          
          h5("Sample Distribution"),
          plotlyOutput(ns("sample_distribution"), height = "250px"),
          
          hr(),
          
          h5("Data Preview"),
          DTOutput(ns("data_preview"))
        )
      )
    )
  )
}

mod_data_loader_server &lt;- function(id, shared_data) {
  moduleServer(id, function(input, output, session) {
    
    observeEvent(input$load_data, {
      withProgress(message = 'Generating example data...', value = 0, {
        
        incProgress(0.2, detail = "Generating counts matrix")
        counts &lt;- generate_example_counts(n_genes = 500, n_samples = 40)
        
        incProgress(0.4, detail = "Generating clinical data")
        clinical &lt;- generate_example_clinical(n_samples = 40)
        
        incProgress(0.6, detail = "Calculating QC metrics")
        qc_metrics &lt;- generate_example_qc(counts)
        
        incProgress(0.8, detail = "Simulating DE results")
        de_results &lt;- generate_example_de(counts)
        
        incProgress(0.9, detail = "Generating pathway results")
        pathway_results &lt;- generate_example_pathways()
        
        shared_data$raw_data &lt;- list(counts = counts, clinical = clinical)
        shared_data$qc_metrics &lt;- qc_metrics
        shared_data$de_results &lt;- de_results
        shared_data$survival_data &lt;- clinical
        shared_data$pathway_results &lt;- pathway_results
        
        incProgress(1.0, detail = "Complete!")
      })
      
      output$load_status &lt;- renderText("Example data loaded successfully!\nReady to explore the dashboard.")
    })
    
    output$data_summary &lt;- renderTable({
      req(shared_data$raw_data)
      
      data.frame(
        Dataset = c("Expression Data", "QC Metrics", "DE Results", "Survival Data", "Pathway Results"),
        Status = c(
          ifelse(is.null(shared_data$raw_data), "Not loaded", "Loaded"),
          ifelse(is.null(shared_data$qc_metrics), "Not loaded", "Loaded"),
          ifelse(is.null(shared_data$de_results), "Not loaded", "Loaded"),
          ifelse(is.null(shared_data$survival_data), "Not loaded", "Loaded"),
          ifelse(is.null(shared_data$pathway_results), "Not loaded", "Loaded")
        ),
        Dimensions = c(
          if (!is.null(shared_data$raw_data)) paste(dim(shared_data$raw_data$counts), collapse = " x ") else "-",
          if (!is.null(shared_data$qc_metrics)) paste(dim(shared_data$qc_metrics), collapse = " x ") else "-",
          if (!is.null(shared_data$de_results)) paste(length(shared_data$de_results), "methods") else "-",
          if (!is.null(shared_data$survival_data)) paste(dim(shared_data$survival_data), collapse = " x ") else "-",
          if (!is.null(shared_data$pathway_results)) paste(dim(shared_data$pathway_results), collapse = " x ") else "-"
        ),
        stringsAsFactors = FALSE
      )
    })
    
    output$sample_distribution &lt;- renderPlotly({
      req(shared_data$qc_metrics)
      
      plot_ly(
        data = shared_data$qc_metrics,
        x = ~total_counts,
        y = ~detected_genes,
        type = 'scatter',
        mode = 'markers',
        marker = list(size = 10, color = ~total_counts, colorscale = 'Viridis', showscale = TRUE),
        text = ~paste("Sample:", sample, "&lt;br&gt;Total counts:", format(total_counts, big.mark = ","), 
                     "&lt;br&gt;Detected genes:", detected_genes),
        hovertemplate = "%{text}&lt;extra&gt;&lt;/extra&gt;"
      ) %&gt;%
        layout(
          xaxis = list(title = "Total Counts"),
          yaxis = list(title = "Detected Genes"),
          hovermode = 'closest',
          margin = list(l = 50, r = 50, t = 20, b = 50)
        )
    })
    
    output$data_preview &lt;- renderDT({
      req(shared_data$qc_metrics)
      
      datatable(
        shared_data$qc_metrics,
        options = list(pageLength = 5, scrollX = TRUE, dom = 'tp'),
        rownames = FALSE
      )
    })
    
    return(reactive({
      list(loaded = !is.null(shared_data$raw_data), source = input$data_source)
    }))
  })
}

# ============================================================================
# Module: QC Visualization (SHORTENED for file size)
# ============================================================================

mod_qc_viz_ui &lt;- function(id) {
  ns &lt;- NS(id)
  
  tagList(
    card(
      card_header("Quality Control Metrics"),
      card_body(
        layout_columns(
          col_widths = c(6, 6),
          plotlyOutput(ns("library_size_plot"), height = "350px"),
          plotlyOutput(ns("pca_plot"), height = "350px")
        ),
        hr(),
        h5("Sample QC Table"),
        DTOutput(ns("qc_table"))
      )
    )
  )
}

mod_qc_viz_server &lt;- function(id, shared_data) {
  moduleServer(id, function(input, output, session) {
    
    output$library_size_plot &lt;- renderPlotly({
      req(shared_data$qc_metrics)
      
      plot_ly(
        data = shared_data$qc_metrics,
        x = ~sample,
        y = ~total_counts,
        type = 'bar',
        marker = list(color = ~total_counts, colorscale = 'Blues', showscale = FALSE),
        text = ~paste("Sample:", sample, "&lt;br&gt;Total counts:", format(total_counts, big.mark = ",")),
        hovertemplate = "%{text}&lt;extra&gt;&lt;/extra&gt;"
      ) %&gt;%
        layout(
          title = "Library Size Distribution",
          xaxis = list(title = "Sample", tickangle = -45),
          yaxis = list(title = "Total Counts"),
          margin = list(b = 100)
        )
    })
    
    output$pca_plot &lt;- renderPlotly({
      req(shared_data$raw_data)
      
      if (is.list(shared_data$raw_data) &amp;&amp; "counts" %in% names(shared_data$raw_data)) {
        counts &lt;- shared_data$raw_data$counts
        log_counts &lt;- log2(counts + 1)
        pca_result &lt;- prcomp(t(log_counts), scale. = TRUE, center = TRUE)
        
        pc_df &lt;- data.frame(
          sample = rownames(pca_result$x),
          PC1 = pca_result$x[,1],
          PC2 = pca_result$x[,2]
        )
        
        var_explained &lt;- round(100 * pca_result$sdev^2 / sum(pca_result$sdev^2), 1)
        
        plot_ly(
          data = pc_df,
          x = ~PC1,
          y = ~PC2,
          type = 'scatter',
          mode = 'markers',
          marker = list(size = 12, color = "#2E86AB"),
          text = ~sample,
          hovertemplate = "Sample: %{text}&lt;br&gt;PC1: %{x:.2f}&lt;br&gt;PC2: %{y:.2f}&lt;extra&gt;&lt;/extra&gt;"
        ) %&gt;%
          layout(
            title = "PCA of Samples",
            xaxis = list(title = paste0("PC1 (", var_explained[1], "% variance)")),
            yaxis = list(title = paste0("PC2 (", var_explained[2], "% variance)"))
          )
      } else {
        plot_ly() %&gt;% layout(title = "PCA Plot", annotations = list(text = "No data", showarrow = FALSE))
      }
    })
    
    output$qc_table &lt;- renderDT({
      req(shared_data$qc_metrics)
      datatable(shared_data$qc_metrics, options = list(pageLength = 10, scrollX = TRUE), rownames = FALSE)
    })
  })
}

# ============================================================================
# Module: Differential Expression (CORE functions)
# ============================================================================

mod_de_viz_ui &lt;- function(id) {
  ns &lt;- NS(id)
  
  tagList(
    layout_columns(
      col_widths = c(3, 9),
      
      card(
        card_header("DE Analysis Controls"),
        card_body(
          selectInput(ns("de_method"), "Select Method:", 
                     choices = c("DESeq2", "edgeR", "limma"), selected = "DESeq2"),
          sliderInput(ns("padj_threshold"), "Adjusted P-value:", min = 0.001, max = 0.1, value = 0.05, step = 0.001),
          sliderInput(ns("lfc_threshold"), "Log2 Fold Change:", min = 0, max = 3, value = 1, step = 0.1),
          hr(),
          h5("Summary"),
          tableOutput(ns("de_summary"))
        )
      ),
      
      card(
        card_header("Differential Expression Results"),
        card_body(
          navset_tab(
            nav_panel("Volcano Plot", plotlyOutput(ns("volcano_plot"), height = "500px")),
            nav_panel("MA Plot", plotlyOutput(ns("ma_plot"), height = "500px")),
            nav_panel("DE Table", DTOutput(ns("de_table")))
          )
        )
      )
    )
  )
}

mod_de_viz_server &lt;- function(id, shared_data) {
  moduleServer(id, function(input, output, session) {
    
    current_de_results &lt;- reactive({
      req(shared_data$de_results)
      if (is.list(shared_data$de_results) &amp;&amp; input$de_method %in% names(shared_data$de_results)) {
        shared_data$de_results[[input$de_method]]
      } else {
        shared_data$de_results[[1]]
      }
    })
    
    output$de_summary &lt;- renderTable({
      req(current_de_results())
      df &lt;- current_de_results()
      
      padj_col &lt;- if ("padj" %in% names(df)) "padj" else if ("FDR" %in% names(df)) "FDR" else "adj.P.Val"
      lfc_col &lt;- if ("log2FoldChange" %in% names(df)) "log2FoldChange" else if ("logFC" %in% names(df)) "logFC" else "log2FC"
      
      n_sig &lt;- sum(df[[padj_col]] &lt; input$padj_threshold, na.rm = TRUE)
      n_up &lt;- sum(df[[padj_col]] &lt; input$padj_threshold &amp; df[[lfc_col]] &gt; input$lfc_threshold, na.rm = TRUE)
      n_down &lt;- sum(df[[padj_col]] &lt; input$padj_threshold &amp; df[[lfc_col]] &lt; -input$lfc_threshold, na.rm = TRUE)
      
      data.frame(
        Metric = c("Total Genes", "Significant", "Upregulated", "Downregulated"),
        Count = c(nrow(df), n_sig, n_up, n_down)
      )
    })
    
    output$volcano_plot &lt;- renderPlotly({
      req(current_de_results())
      df &lt;- current_de_results()
      
      padj_col &lt;- if ("padj" %in% names(df)) "padj" else if ("FDR" %in% names(df)) "FDR" else "adj.P.Val"
      lfc_col &lt;- if ("log2FoldChange" %in% names(df)) "log2FoldChange" else if ("logFC" %in% names(df)) "logFC" else "log2FC"
      
      df$significance &lt;- ifelse(
        df[[padj_col]] &lt; input$padj_threshold &amp; abs(df[[lfc_col]]) &gt; input$lfc_threshold,
        ifelse(df[[lfc_col]] &gt; 0, "Up", "Down"),
        "Not Significant"
      )
      
      colors &lt;- c("Up" = "#DC3545", "Down" = "#0066CC", "Not Significant" = "#CCCCCC")
      
      plot_ly(
        data = df,
        x = ~get(lfc_col),
        y = ~-log10(get(padj_col)),
        type = 'scatter',
        mode = 'markers',
        color = ~significance,
        colors = colors,
        marker = list(size = 5),
        text = ~paste("Gene:", gene, "&lt;br&gt;Log2FC:", round(get(lfc_col), 3), 
                     "&lt;br&gt;Adj P:", format(get(padj_col), digits = 3)),
        hovertemplate = "%{text}&lt;extra&gt;&lt;/extra&gt;"
      ) %&gt;%
        layout(
          title = paste("Volcano Plot -", input$de_method),
          xaxis = list(title = "Log2 Fold Change"),
          yaxis = list(title = "-Log10(Adjusted P-value)"),
          shapes = list(
            list(type = 'line', x0 = input$lfc_threshold, x1 = input$lfc_threshold,
                 y0 = 0, y1 = 1, yref = "paper",
                 line = list(color = 'gray', dash = 'dash', width = 1)),
            list(type = 'line', x0 = -input$lfc_threshold, x1 = -input$lfc_threshold,
                 y0 = 0, y1 = 1, yref = "paper",
                 line = list(color = 'gray', dash = 'dash', width = 1)),
            list(type = 'line', x0 = 0, x1 = 1, xref = "paper",
                 y0 = -log10(input$padj_threshold), y1 = -log10(input$padj_threshold),
                 line = list(color = 'gray', dash = 'dash', width = 1))
          )
        )
    })
    
    output$ma_plot &lt;- renderPlotly({
      req(current_de_results())
      df &lt;- current_de_results()
      
      padj_col &lt;- if ("padj" %in% names(df)) "padj" else if ("FDR" %in% names(df)) "FDR" else "adj.P.Val"
      lfc_col &lt;- if ("log2FoldChange" %in% names(df)) "log2FoldChange" else if ("logFC" %in% names(df)) "logFC" else "log2FC"
      
      if ("baseMean" %in% names(df)) {
        df$avg_expr &lt;- log10(df$baseMean + 1)
      } else if ("AveExpr" %in% names(df)) {
        df$avg_expr &lt;- df$AveExpr
      } else {
        df$avg_expr &lt;- runif(nrow(df), 0, 5)
      }
      
      df$significance &lt;- ifelse(
        df[[padj_col]] &lt; input$padj_threshold &amp; abs(df[[lfc_col]]) &gt; input$lfc_threshold,
        "Significant", "Not Significant"
      )
      
      colors &lt;- c("Significant" = "#DC3545", "Not Significant" = "#CCCCCC")
      
      plot_ly(
        data = df,
        x = ~avg_expr,
        y = ~get(lfc_col),
        type = 'scatter',
        mode = 'markers',
        color = ~significance,
        colors = colors,
        marker = list(size = 4),
        text = ~paste("Gene:", gene, "&lt;br&gt;Avg Expression:", round(avg_expr, 2), 
                     "&lt;br&gt;Log2FC:", round(get(lfc_col), 3)),
        hovertemplate = "%{text}&lt;extra&gt;&lt;/extra&gt;"
      ) %&gt;%
        layout(
          title = paste("MA Plot -", input$de_method),
          xaxis = list(title = "Average Expression (log10)"),
          yaxis = list(title = "Log2 Fold Change")
        )
    })
    
    output$de_table &lt;- renderDT({
      req(current_de_results())
      df &lt;- current_de_results()
      numeric_cols &lt;- sapply(df, is.numeric)
      df[numeric_cols] &lt;- lapply(df[numeric_cols], function(x) round(x, 4))
      datatable(df, options = list(pageLength = 25, scrollX = TRUE), rownames = FALSE, filter = 'top')
    })
  })
}

# ============================================================================
# Module: Survival Analysis
# ============================================================================

mod_survival_viz_ui &lt;- function(id) {
  ns &lt;- NS(id)
  
  tagList(
    layout_columns(
      col_widths = c(3, 9),
      
      card(
        card_header("Survival Controls"),
        card_body(
          radioButtons(ns("survival_type"), "Survival Endpoint:",
                      choices = c("Overall Survival" = "os", "Progression-Free Survival" = "pfs"),
                      selected = "os"),
          selectInput(ns("group_by"), "Group By:",
                     choices = c("Risk Group" = "risk_group", "ISS Stage" = "stage", "None" = "none"),
                     selected = "risk_group"),
          hr(),
          h5("Summary"),
          tableOutput(ns("survival_summary"))
        )
      ),
      
      card(
        card_header("Survival Analysis Results"),
        card_body(
          plotlyOutput(ns("km_plot"), height = "500px"),
          hr(),
          verbatimTextOutput(ns("km_stats"))
        )
      )
    )
  )
}

mod_survival_viz_server &lt;- function(id, shared_data) {
  moduleServer(id, function(input, output, session) {
    
    output$survival_summary &lt;- renderTable({
      req(shared_data$survival_data)
      surv_data &lt;- shared_data$survival_data
      
      time_col &lt;- if (input$survival_type == "os") "os_time" else "pfs_time"
      status_col &lt;- if (input$survival_type == "os") "os_status" else "pfs_status"
      
      if (time_col %in% names(surv_data) &amp;&amp; status_col %in% names(surv_data)) {
        data.frame(
          Metric = c("Total Patients", "Events", "Censored", "Median Follow-up"),
          Value = c(
            nrow(surv_data),
            sum(surv_data[[status_col]], na.rm = TRUE),
            sum(!surv_data[[status_col]], na.rm = TRUE),
            round(median(surv_data[[time_col]], na.rm = TRUE), 1)
          )
        )
      } else {
        data.frame(Metric = "No data", Value = "-")
      }
    })
    
    output$km_plot &lt;- renderPlotly({
      req(shared_data$survival_data)
      
      surv_data &lt;- shared_data$survival_data
      time_col &lt;- if (input$survival_type == "os") "os_time" else "pfs_time"
      status_col &lt;- if (input$survival_type == "os") "os_status" else "pfs_status"
      title_text &lt;- if (input$survival_type == "os") "Overall Survival" else "Progression-Free Survival"
      
      if (!time_col %in% names(surv_data) || !status_col %in% names(surv_data)) {
        return(plot_ly() %&gt;% layout(title = title_text, 
                                    annotations = list(text = "No data", showarrow = FALSE)))
      }
      
      if (input$group_by != "none" &amp;&amp; input$group_by %in% names(surv_data)) {
        formula &lt;- as.formula(paste0("Surv(", time_col, ", ", status_col, ") ~ ", input$group_by))
        fit &lt;- survfit(formula, data = surv_data)
        
        groups &lt;- unique(surv_data[[input$group_by]])
        colors &lt;- c("#2E86AB", "#A23B72", "#F18F01")
        
        p &lt;- plot_ly()
        for (i in seq_along(groups)) {
          idx &lt;- which(fit$strata == i)
          if (length(idx) &gt; 0) {
            p &lt;- add_trace(p,
              x = c(0, fit$time[idx]),
              y = c(1, fit$surv[idx]),
              type = 'scatter',
              mode = 'lines',
              line = list(shape = 'hv', color = colors[i], width = 2),
              name = as.character(groups[i]),
              hovertemplate = paste0("Time: %{x}&lt;br&gt;Survival: %{y:.2%}&lt;extra&gt;&lt;/extra&gt;")
            )
          }
        }
        
        p &lt;- layout(p,
          title = paste(title_text, "by", input$group_by),
          xaxis = list(title = "Time (days)"),
          yaxis = list(title = "Survival Probability", range = c(0, 1))
        )
      } else {
        formula &lt;- as.formula(paste0("Surv(", time_col, ", ", status_col, ") ~ 1"))
        fit &lt;- survfit(formula, data = surv_data)
        
        p &lt;- plot_ly(
          x = c(0, fit$time),
          y = c(1, fit$surv),
          type = 'scatter',
          mode = 'lines',
          line = list(shape = 'hv', color = '#2E86AB', width = 2),
          hovertemplate = "Time: %{x}&lt;br&gt;Survival: %{y:.2%}&lt;extra&gt;&lt;/extra&gt;"
        ) %&gt;%
          layout(
            title = title_text,
            xaxis = list(title = "Time (days)"),
            yaxis = list(title = "Survival Probability", range = c(0, 1))
          )
      }
      
      p
    })
    
    output$km_stats &lt;- renderPrint({
      req(shared_data$survival_data)
      
      surv_data &lt;- shared_data$survival_data
      time_col &lt;- if (input$survival_type == "os") "os_time" else "pfs_time"
      status_col &lt;- if (input$survival_type == "os") "os_status" else "pfs_status"
      
      if (time_col %in% names(surv_data) &amp;&amp; status_col %in% names(surv_data)) {
        if (input$group_by != "none" &amp;&amp; input$group_by %in% names(surv_data)) {
          formula &lt;- as.formula(paste0("Surv(", time_col, ", ", status_col, ") ~ ", input$group_by))
          survdiff_result &lt;- survdiff(formula, data = surv_data)
          p_value &lt;- 1 - pchisq(survdiff_result$chisq, length(survdiff_result$n) - 1)
          cat("Log-rank test p-value:", format(p_value, digits = 4), "\n\n")
          fit &lt;- survfit(formula, data = surv_data)
          print(fit)
        } else {
          formula &lt;- as.formula(paste0("Surv(", time_col, ", ", status_col, ") ~ 1"))
          fit &lt;- survfit(formula, data = surv_data)
          print(fit)
        }
      } else {
        cat("Survival data not available")
      }
    })
  })
}

# ============================================================================
# Module: Pathway Analysis
# ============================================================================

mod_pathway_viz_ui &lt;- function(id) {
  ns &lt;- NS(id)
  
  tagList(
    card(
      card_header("Pathway Analysis Results"),
      card_body(
        navset_tab(
          nav_panel(
            "Enrichment Results",
            layout_columns(
              col_widths = c(6, 6),
              plotlyOutput(ns("enrichment_plot"), height = "500px"),
              plotlyOutput(ns("dotplot"), height = "500px")
            ),
            hr(),
            DTOutput(ns("pathway_table"))
          ),
          nav_panel(
            "GSEA Results",
            plotlyOutput(ns("gsea_plot"), height = "500px"),
            hr(),
            DTOutput(ns("gsea_table"))
          )
        )
      )
    )
  )
}

mod_pathway_viz_server &lt;- function(id, shared_data) {
  moduleServer(id, function(input, output, session) {
    
    output$enrichment_plot &lt;- renderPlotly({
      req(shared_data$pathway_results)
      df &lt;- shared_data$pathway_results
      
      if (!all(c("pathway", "p_value") %in% names(df))) {
        return(plot_ly() %&gt;% layout(title = "No data"))
      }
      
      top_pathways &lt;- df %&gt;%
        arrange(p_value) %&gt;%
        head(15) %&gt;%
        mutate(
          neg_log_p = -log10(p_value),
          pathway = factor(pathway, levels = rev(pathway))
        )
      
      plot_ly(
        data = top_pathways,
        x = ~neg_log_p,
        y = ~pathway,
        type = 'bar',
        orientation = 'h',
        marker = list(color = ~neg_log_p, colorscale = list(c(0, "#E8F4F8"), c(1, "#0066CC")),
                     showscale = TRUE, colorbar = list(title = "-Log10(P)")),
        text = ~paste("Pathway:", pathway, "&lt;br&gt;P-value:", format(p_value, digits = 3)),
        hovertemplate = "%{text}&lt;extra&gt;&lt;/extra&gt;"
      ) %&gt;%
        layout(
          title = "Top Enriched Pathways",
          xaxis = list(title = "-Log10(P-value)"),
          yaxis = list(title = "", tickfont = list(size = 10)),
          margin = list(l = 250)
        )
    })
    
    output$dotplot &lt;- renderPlotly({
      req(shared_data$pathway_results)
      df &lt;- shared_data$pathway_results
      
      top_pathways &lt;- df %&gt;% arrange(p_value) %&gt;% head(15)
      top_pathways$gene_ratio &lt;- top_pathways$gene_count / top_pathways$pathway_size
      top_pathways$q_value &lt;- p.adjust(top_pathways$p_value, method = "BH")
      
      plot_ly(
        data = top_pathways,
        x = ~gene_ratio,
        y = ~reorder(pathway, -p_value),
        type = 'scatter',
        mode = 'markers',
        marker = list(size = ~gene_count * 2, color = ~-log10(q_value), colorscale = 'Reds',
                     showscale = TRUE, colorbar = list(title = "-Log10(Q)")),
        text = ~paste("Pathway:", pathway, "&lt;br&gt;Gene Ratio:", round(gene_ratio, 3), 
                     "&lt;br&gt;Q-value:", format(q_value, digits = 3)),
        hovertemplate = "%{text}&lt;extra&gt;&lt;/extra&gt;"
      ) %&gt;%
        layout(
          title = "Pathway Enrichment Dotplot",
          xaxis = list(title = "Gene Ratio"),
          yaxis = list(title = "", tickfont = list(size = 10)),
          margin = list(l = 250)
        )
    })
    
    output$pathway_table &lt;- renderDT({
      req(shared_data$pathway_results)
      datatable(shared_data$pathway_results, 
               options = list(pageLength = 25, scrollX = TRUE), 
               rownames = FALSE, filter = 'top')
    })
    
    output$gsea_plot &lt;- renderPlotly({
      req(shared_data$pathway_results)
      df &lt;- shared_data$pathway_results
      
      if ("NES" %in% names(df)) {
        sig_sets &lt;- df %&gt;% filter(q_value &lt; 0.25) %&gt;% arrange(desc(abs(NES))) %&gt;% head(20)
        
        plot_ly(
          data = sig_sets,
          x = ~NES,
          y = ~reorder(pathway, NES),
          type = 'bar',
          orientation = 'h',
          marker = list(color = ~ifelse(NES &gt; 0, "#DC3545", "#0066CC")),
          text = ~paste("Gene Set:", pathway, "&lt;br&gt;NES:", round(NES, 2), 
                       "&lt;br&gt;Q-value:", format(q_value, digits = 3)),
          hovertemplate = "%{text}&lt;extra&gt;&lt;/extra&gt;"
        ) %&gt;%
          layout(
            title = "GSEA - Normalized Enrichment Scores",
            xaxis = list(title = "NES", zeroline = TRUE),
            yaxis = list(title = "", tickfont = list(size = 9)),
            margin = list(l = 300)
          )
      } else {
        plot_ly() %&gt;% layout(title = "No GSEA results")
      }
    })
    
    output$gsea_table &lt;- renderDT({
      req(shared_data$pathway_results)
      datatable(shared_data$pathway_results, 
               options = list(pageLength = 25, scrollX = TRUE), 
               rownames = FALSE)
    })
  })
}

# ============================================================================
# Main App
# ============================================================================

ui &lt;- page_navbar(
  title = "CoMMpass Analysis Dashboard",
  theme = bs_theme(
    version = 5,
    primary = "#0066CC",
    secondary = "#6C757D",
    success = "#28A745",
    info = "#17A2B8",
    warning = "#FFC107",
    danger = "#DC3545"
  ),
  
  nav_panel(
    title = "Overview",
    icon = icon("home"),
    card(
      card_header("CoMMpass Multiple Myeloma Analysis"),
      card_body(
        h4("Welcome to the CoMMpass Analysis Dashboard"),
        p("This interactive dashboard runs entirely in your web browser using WebAssembly (Shinylive)."),
        hr(),
        h5("Dataset Overview"),
        p("Simulated CoMMpass-like data includes:"),
        tags$ul(
          tags$li("500 genes, 40 samples"),
          tags$li("RNA-seq expression data"),
          tags$li("Simulated survival outcomes"),
          tags$li("Pathway enrichment results")
        ),
        hr(),
        h5("Analysis Modules"),
        tags$ul(
          tags$li(strong("Data:"), " Load and preview example data"),
          tags$li(strong("Quality Control:"), " Sample QC metrics, PCA visualization"),
          tags$li(strong("Differential Expression:"), " Volcano plots, MA plots (DESeq2, edgeR, limma)"),
          tags$li(strong("Survival Analysis:"), " Kaplan-Meier curves, log-rank tests"),
          tags$li(strong("Pathway Analysis:"), " Enrichment analysis and GSEA results")
        ),
        hr(),
        div(
          class = "alert alert-info",
          icon("info-circle"),
          " Start by clicking the ", strong("Data"), " tab and loading the example dataset."
        ),
        hr(),
        h5("Example ggplot2 Visualization"),
        p("Demonstrating ggplot2 works in Shinylive with all dependencies:"),
        plotOutput("example_ggplot", height = "300px")
      )
    )
  ),
  
  nav_panel(title = "Data", icon = icon("database"), mod_data_loader_ui("data_loader")),
  nav_panel(title = "Quality Control", icon = icon("chart-line"), mod_qc_viz_ui("qc_viz")),
  nav_panel(title = "Differential Expression", icon = icon("dna"), mod_de_viz_ui("de_viz")),
  nav_panel(title = "Survival Analysis", icon = icon("heartbeat"), mod_survival_viz_ui("survival_viz")),
  nav_panel(title = "Pathway Analysis", icon = icon("project-diagram"), mod_pathway_viz_ui("pathway_viz")),
  
  nav_panel(
    title = "About",
    icon = icon("info-circle"),
    card(
      card_header("About This Dashboard"),
      card_body(
        h5("Technology"),
        p("Built with R Shiny and Shinylive for browser-based execution without R server."),
        p("All computations run in your browser using WebAssembly."),
        hr(),
        h5("Data Source"),
        p("This demo uses simulated data similar to the MMRF CoMMpass study (phs000748)."),
        hr(),
        h5("Performance"),
        p("First load takes 30-60 seconds while packages download. Subsequent visits are faster due to browser caching.")
      )
    )
  )
)

server &lt;- function(input, output, session) {
  shared_data &lt;- reactiveValues(
    raw_data = NULL,
    qc_metrics = NULL,
    de_results = NULL,
    survival_data = NULL,
    pathway_results = NULL
  )

  # Example ggplot2 visualization showing it works with munsell colors
  output$example_ggplot &lt;- renderPlot({
    set.seed(123)
    data &lt;- data.frame(
      category = rep(c("High Risk", "Standard Risk", "Low Risk"), each = 100),
      value = c(rnorm(100, 5, 2), rnorm(100, 7, 1.5), rnorm(100, 9, 1))
    )

    ggplot(data, aes(x = category, y = value, fill = category)) +
      geom_violin(alpha = 0.7) +
      geom_boxplot(width = 0.2, alpha = 0.9) +
      scale_fill_manual(values = c("High Risk" = "#E63946",
                                  "Standard Risk" = "#F1C40F",
                                  "Low Risk" = "#2ECC71")) +
      theme_minimal() +
      theme(legend.position = "none",
            plot.title = element_text(size = 14, face = "bold")) +
      labs(title = "Risk Stratification Distribution (ggplot2)",
           x = "Risk Category",
           y = "Expression Score") +
      coord_cartesian(ylim = c(0, 12))
  })

  mod_data_loader_server("data_loader", shared_data)
  mod_qc_viz_server("qc_viz", shared_data)
  mod_de_viz_server("de_viz", shared_data)
  mod_survival_viz_server("survival_viz", shared_data)
  mod_pathway_viz_server("pathway_viz", shared_data)
}

shinyApp(ui = ui, server = server)</code></pre>
</section>
<section id="usage-instructions" class="level2">
<h2 class="anchored" data-anchor-id="usage-instructions">Usage Instructions</h2>
<ol type="1">
<li><strong>First Time Load</strong>: Allow 30-60 seconds for WebAssembly packages to download</li>
<li><strong>Load Data</strong>: Click the “Data” tab and press “Load Example Data”</li>
<li><strong>Explore</strong>: Navigate through the tabs to explore different analyses</li>
<li><strong>Interactive</strong>: All plots are interactive - hover for details, zoom, pan</li>
</ol>
</section>
<section id="technical-notes" class="level2">
<h2 class="anchored" data-anchor-id="technical-notes">Technical Notes</h2>
<ul>
<li>Runs completely in browser (no R server needed)</li>
<li>Data persists during session but resets on page reload</li>
<li>All packages cached in browser after first load</li>
<li>Works offline after initial package download</li>
</ul>
</section>
<section id="building-this-vignette" class="level2">
<h2 class="anchored" data-anchor-id="building-this-vignette">Building This Vignette</h2>
<p>To build this Shinylive vignette locally:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install Quarto and the Shinylive extension</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">quarto</span> add quarto-ext/shinylive</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Render the document</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ex">quarto</span> render vignettes/dashboard_shinylive.qmd</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To deploy to GitHub Pages, the rendered HTML file includes all necessary JavaScript and WebAssembly components.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>